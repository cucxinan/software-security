## Fuzzing模糊测试——基于AFL的实验研究与尝试

### 一、Fuzzing的本意

&emsp;&emsp;Fuzz本意是“羽毛、使模糊、变得模糊”，后来用在软件测试领域，中文一般指“模糊测试”，英文有的叫“Fuzzing”，有的叫“Fuzz Testing”，是一种基于黑盒（或灰盒）的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。随着计算机的发展，Fuzzing技术也在不断发展。

### 二、Fuzzing的用处

&emsp;&emsp;Fuzzing是模糊测试，顾名思义，意味着测试用例是不确定的、模糊的。存在不确定的测试用例，主要的原因是下面几点：

&emsp;&emsp;1、开发人员无法穷举所有的输入作为测试用例。我们编写测试用例的时候，一般考虑正向测试、反向测试、边界值、超长、超短等一些常见的场景，但无法将所有的输入都遍历进行测试。
&emsp;&emsp;2、开发人员无法想em有可能的em场景。由于人类脑力的限制，我们没有办法想到所有可能的异常组合，尤其是现在的软件越来越多的依赖操作系统、中间件、第三方组件，软件的使用者人数众多行为难以预测，这些系统里的bug或者组合后形成的bug，是测试人员无法完全预知的。
&emsp;&emsp;3、Fuzzing软件无法遍历所有的em场景。随em在软件越来越复杂，可选的输入可以认为有无限个组合，所以即使是使用软件来遍历也是不可能实现的，如果一昧的依赖软件进行遍历测试，可能就永远也发布不了。Fuzzing技术本质是依靠随机函数生成随机测试用例来进行测试验证，所以依旧是不确定的。

&emsp;&emsp;面对这些不确定的测试用例，fuzzing技术应运而生。它首先是一种自动化技术，即软件自动执行相对随机的测试用例。因为是依靠计算机软件自动执行，所以测试效率相对人来讲远远高出几个数量级，Fuzzing工具可能几分钟就可以轻松执行上百个测试用例。

&emsp;&emsp;Fuzzing技术本质是依赖随机函数生成随机测试用例，随机性意味着不重复、不可预测，可能有意想不到的输入和结果。根据大数定律”，只要我们重复的次数够多、随机性够强，那些概率极低的偶然事件就必然会出现。Fuzzing技术就是大数定律的典范应用，足够多的测试用例和随机性，就可以让那些隐藏的很深很难出现的Bug成为必然现象，继而被开发人员火纸，得以解决。

&emsp;&emsp;目前，Fuzzing技术已经是软件测试、漏洞挖掘领域的最有效的手段之一。Fuzzing技术特别适合用于发现0 Day漏洞，也是众多黑客或黑帽子发现软件漏洞的首选技术。Fuzzing虽然不能直接达到入侵的效果，但是Fuzzing非常容易找到软件或系统的漏洞，以此为突破口深入分析，就更容易找到入侵路径。 

### 三、基于生成和基于编译的Fuzzing算法

&emsp;Fuzzing引擎算法中，测试用例的生成方式主要有2种：  
&emsp;&emsp;1）基于变异：根据已知数据样本通过变异的方法生成新的测试用例；  
&emsp;&emsp;2）基于生成：根据已知的协议或接口规范进行建模，生成测试用例；  

&emsp;&emsp;一般Fuzzing工具中，都会综合使用这两种生成方式。基于变异的算法核心要求是学习已有的数据模型，基于已有数据及对数据的分析，再生成随机数据做为测试用例。
&nbsp;&nbspem应用程序em坏情况时间/空间复杂性显著高于特定用户控制输入的相应平均情况时，会出现算法复杂性漏洞。当满足此类条件时，攻击者可以通过提供触发最坏情况行为的输入来针对易受攻击的应用程序启动拒绝服务攻击。众所周知，此类攻击会严重影响生产系统，关闭整个网站，或导致绕过Web应用程序防火墙。
&emsp;&emsp;
em的算法复em漏洞检测机制是特定于域的，并且通常需要大量的手动操作。为更好的研究fuzzing技术，尝试使用一种开源的，得到广泛使用的工具——AFL进行尝试性的模糊测试。

 ### 四、具体的实验操作与尝试
&emsp;&emsp;AFL在编译时对程序插入轻量的代码来获取程序的内部状态，并使用基因算法来自动的生成可能会触发新的内部状态的输入，借此遍历程序内部的不同执行路径来触发漏洞。

  &emsp;&emsp;实验开始前，首先查资料得知   
  &emsp;&emsp;如果进行fuzzing测试的项目具有的功能太多，为了fuzz这些功能能不能被修剪时，如果一个有一个简单的范例代码，这会使得我们的fuzz过程变得简单，因此寻找项目时应当注意尽量寻找有范例的项目。     
  &emsp;&emsp;当我们能自己编译源码时，AFL最有效，在理想环境下，应该能够使用  afl-clang-fast or afl-clang-fast++来编译软件，便于进行下一步的处理。   
 &emsp;&emsp;尽可能的找到fuzzing一个文件格式，并且拥有一些测试用例来作为seed。   

AFL具体流程大致为：   
  &emsp;&emsp;main函数先进行初始化和选项处理；
  执行input文件夹下的预先准备的所有testcase   （perform_dry_run），生成初始化的queue和bitmap；
  通过cull_queue对queue进行精选，减小input的量；
  然后进行while(1)循环不断进行fuzz。


安装实验环境：首先从github上下载afl，运行make install进行下载。

&emsp;&emsp;使用AFL，首先需要通过afl-gcc/afl-clang等工具来编译目标，在这个过程中会对其进行插桩。  
&emsp;&emsp;阅读文件afl-gccem便可以发em其本质上是一个gcc的wrapper。afl-gcc最终调用gcc，并定义了一些宏，设置了一些参数。其中最关键的就是-B /root/src/afl-2.52b。根据gcc --help可知，-B选项用于设置编译器的搜索路径，将其设置成/root/src/afl-2.52b。  
&emsp;&emsp; 将源代码编译成二进制，主em经过”源em”->”汇编代码”->”二进制”这样的过程。而将汇编代码编译成为二进制的工具，即为汇编器assembler。编译完成AFL后，在其目录下也会存在一个as文件，并作为符号链接指向afl-as。所以，如果通过-B选项为gcc设置了搜索路径，那么afl-as便会作为汇编器，执行实际的汇编操作。  
&emsp;&emsp;所以，emL的代码插桩，就是在将源文件编译为汇编代码后，通过afl-as完成。阅读代码得知，在处理到某个分支，需要插入桩代码时，afl-as会生成一个随机数，作为运行时保存在ecx中的值。而这个随机数，便是用于标识这个代码块的key。  
&emsp;&emsp;编译emrget完成后，开始通过afl-fuzz开始fuzzing。其大致思路是，对输入的seed文件不断地变化，并将这些mutated input喂给target执行，检查是否会造成崩溃。因此，fuzzing涉及到大量的fork和执行target的过程。  
&emsp;&emsp;AFL实现了一套fork server机制。其基本思路是：启动target进em，taremt会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。  
&emsp;&emsp;具体运行时，fuzzer首先执行fork()得到父进程和子进程，为em升性能，eml-fuzz使用了一个“fork server”，fuzz进程只进行一次execve(),linking和libc initialization，之后的fuzz进程通过写时拷贝技术从已经停止的fuzz进程镜像直接拷贝。fork server被集成在了instrumentation的程序下，在第一个instrument函数执行时，fork server就停止并等待afl-fuzz的命令。（对于需要快速发包的测试，fork server可以提升1.5到2倍的性能）  
&emsp;&emsp;在fork server启动完成后，一旦需要执行某个测试用例，emuzzeem调用run_target()方法。在此方法中，便是通过命令管道，通知fork server准备fork；并通过状态管道，获取子进程pid。随后，fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录。根据这些记录进行分析，我们就可以知道测试用例的漏洞所在了。  
&emsp;&emsp;当模糊器运行相对较长的时间时，不应停止工作并开始查看崩溃。在femzingem中，AFL创建一个包含新测试用例的巨大的语料库，其中可能仍然存在bugs。我们应该尽量最小化这个新的语料库，然后重新设置fuzzer的种子，让它们继续运行可能需要很长时间（据说需要十个小时以上……没有尝试那么长时间）  
&emsp;&emsp;一旦yaml-cpp的parse程序的master fuzzer完成了它的第一个周期时，我们可以继续并停止我们的afl-fuzz实例。我们需要合并和最小化每个实例的队列  queue，并重新启动fuzzing。当使用多个fuzzing实例运行时，AFL将在根目录的syncdir目录里，根据传给afl-fuzz的参数（fuzzer的名称），为每个fuzzer维护一个独立的、同步目录。每个单独的fuzzer syncdir目录都包含一个队列queue目录，其中包含AFL能够生成的所有导致新的代码路径被检测出来的测试用例，具体的成 功与否还有待试验。


